<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>SFZ Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 2em;
      background: #f4f4f4;
    }

    input,
    textarea,
    button,
    label {
      width: 100%;
      margin: 10px 0;
      font-size: 1em;
    }

    textarea {
      height: 300px;
    }

    .hidden {
      display: none;
    }
  </style>
</head>

<body>
  <h2>SFZ Generator mit optionalen Velocity-Layers & ZIP Export</h2>

  <p>Dieses Tool generiert Multisample-SFZ-Dateien mit gleichmäßig verteilten Notennummern über eine Oktave.</p>

  <label>Author:</label>
  <input type="text" id="author" placeholder="Your Name" value="Your Name">

  <label>Notennamen pro Oktave (z.B. C, D#, F, G#):</label>
  <input type="text" id="notes" placeholder="C, D#, F#, A" value="C, D#, F#, A">

  <label>Anzahl der Oktaven:</label>
  <input type="number" id="octaves" value="3">

  <label>Dateinamen-Pattern (Nutze [Note], [Layer]):</label>
  <input type="text" id="filenamePattern" value="Piano_[Note]_vel[Layer].wav">

  <label>Sample-Ordner (optional, z.B. Samples/Piano):</label>
  <input type="text" id="folder" value="Samples/Piano">

  <div>
    <label>Velocity-Layers aktivieren<input type="checkbox" id="useVelocity" onchange="toggleVelocity()"></label>
    <div id="velocityOptions" class="hidden">
      <br>
      <label>Velocity-Bereiche (z.B. 0-40,41-90,91-127):</label>
      <input type="text" id="velocityRanges" value="0-40,41-90,91-127">
    </div>
  </div>
  <br>
  <label>Name der SFZ-Datei (ohne .sfz):</label>
  <input type="text" id="sfzName" value="instrument">

  <button onclick="generateSFZ()">SFZ generieren</button>
  <button onclick="downloadSFZ()">als ZIP herunterladen</button>

  <label>SFZ Vorschau: (editierbar)</label>
  <textarea id="output"></textarea>

  <script>
    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    errorCode = 2; // kein Output
    const errorCodes = {
      0: 'Keine Fehler',
      1: 'Ungueltiger Notenname',
      2: 'Kein Output',
      3: "Ungültige Velocity-Bereiche: Achte auf Reihenfolge und Werte von 0–127."
    };

    function toggleVelocity() {
      const checkbox = document.getElementById("useVelocity");
      document.getElementById("velocityOptions").classList.toggle("hidden", !checkbox.checked);
    }

    function noteToMidi(note, octave) {
      const index = NOTE_NAMES.indexOf(note);
      return index + (octave + 1) * 12;
    }

    function midiToNote(midi) {
      const name = NOTE_NAMES[midi % 12];
      const octave = Math.floor(midi / 12) - 1;
      return `${name}${octave}`;
    }

    function parseVelocityRanges(input) {
      return input.split(',').map(range => {
        const [low, high] = range.split('-').map(n => parseInt(n.trim()));
        return { low, high };
      });
    }

    function generateSFZContent(header, author, noteInput, octaves, pattern, folder, useVel, velocityRanges) {
      const noteNames = noteInput.split(',').map(n => n.trim());
      let notes = [];

      for (let oct = 0; oct < octaves; oct++) {
        for (let note of noteNames) {
          if (!NOTE_NAMES.includes(note)) {
            errorCode = 1;
            alert(`Fehler: ${errorCodes[errorCode]}`);
            return errorCode;
          }
          let midi = noteToMidi(note, oct);
          notes.push({ note: note, octave: oct, midi: midi });
        }
      }

      notes.sort((a, b) => a.midi - b.midi);
      let result = "";
      result += `//Author: ${author}\n`;
      result += `//Generiert am: ${new Date().toUTCString()}\n`;
      result += header;

      for (let i = 0; i < notes.length; i++) {
        const current = notes[i];
        const midi = current.midi;
        let low, high;

        // erste Note
        if (i === 0) {
          const next = notes[i + 1];
          const split = Math.floor((next.midi - midi) / 2);
          low = 0;
          high = midi + split;
          // letzte Note
        } else if (i === notes.length - 1) {
          const prev = notes[i - 1];
          const split = Math.floor((midi - prev.midi) / 2);          
          low = midi - split + 1; // um 1 anheben, um Ueberschneidungen zu verhindern 
          high = 127;
          // alle Noten zwischen erster und letzter Note
        } else {
          const prev = notes[i - 1];
          const next = notes[i + 1];
          const lowSplit = Math.ceil((midi - prev.midi) / 2); // Aufrunden
          const highSplit = Math.floor((next.midi - midi) / 2);
          low = midi - lowSplit + 1; // um 1 anheben, um Ueberschneidungen zu verhindern
          high = midi + highSplit;
        }

        const noteLabel = `${current.note}${current.octave}`;

        if (useVel) {
          velocityRanges.forEach((range, idx) => {
            const filename = `${folder}/${pattern.replace("[Note]", noteLabel).replace("[Layer]", (idx + 1))}`;
            result += `<region>\n`;
            result += `sample=${filename}\n`;
            result += `lokey=${low}\n`;
            result += `hikey=${high}\n`;
            result += `pitch_keycenter=${midi}\n`;
            result += `lovel=${range.low}\n`;
            result += `hivel=${range.high}\n\n`;
          });
        } else {
          const filename = `${folder}/${pattern.replace("[Note]", noteLabel).replace("_vel[Layer]", "")}`;
          result += `<region>\n`;
          result += `sample=${filename}\n`;
          result += `lokey=${low}\n`;
          result += `hikey=${high}\n`;
          result += `pitch_keycenter=${midi}\n\n`;
        }
      }
      errorCode = 0; // alles Ok
      return result.trim();
    }

    function isValidVelocityRanges(ranges) {
      for (let i = 0; i < ranges.length; i++) {
        const { low, high } = ranges[i];
        if (low < 0 || high > 127 || low > high) return false;
        if (i > 0 && ranges[i - 1].high >= low) return false;
      }
      return true;
    }

    function generateSFZ() {
      const header = "//Tool: https://easypx.github.io/SFZ-Generator | https://www.youtube.com/@Klangraum \n//Version: 202250416\n\n";
      const author = document.getElementById("author").value;
      const notes = document.getElementById("notes").value;
      const octaves = parseInt(document.getElementById("octaves").value);
      const pattern = document.getElementById("filenamePattern").value;
      const folder = document.getElementById("folder").value;
      const useVel = document.getElementById("useVelocity").checked;
      const velRangeInput = document.getElementById("velocityRanges").value;
      const velocityRanges = useVel ? parseVelocityRanges(velRangeInput) : [];
      if (useVel && !isValidVelocityRanges(velocityRanges)) {
        errorCode = 3;
        alert(`Fehler: ${errorCodes[errorCode]}`);
        return;
      }

      const sfzContent = generateSFZContent(header, author, notes, octaves, pattern, folder, useVel, velocityRanges);
      document.getElementById("output").value = sfzContent;
    }

    function downloadSFZ() {
      if (errorCode > 0) {
        alert(`Fehler: ${errorCodes[errorCode]}`);
        return;
      }

      else if (errorCode == 0) {
        const zip = new JSZip();
        sfzContent = document.getElementById("output").value;
        const sfzName = document.getElementById("sfzName").value || "instrument";
        zip.file(`${sfzName}.sfz`, sfzContent);
        zip.generateAsync({ type: "blob" }).then(function (blob) {
          saveAs(blob, `${sfzName}.zip`);
        });
      }
    }

  </script>
</body>

</html>